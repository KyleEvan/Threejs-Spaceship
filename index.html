
<html lang="en">
	<head>
		<title>three.js webgl - pipes screensaver</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}
			a {
				color: #a06851;
			}
		</style>
	</head>
	<body>

		<div id="container"><br /><br /><br /><br /><br />Generating world...</div>
		<div id="info"><a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl pipes screensaver </div>

		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/ImprovedNoise.js"></script>
		<script src="js/WebGL.js"></script>
    <script src="js/stats.min.js"></script>
		<script src="js/Tween.js"></script>

		<script>
			if ( WEBGL.isWebGLAvailable() === false ) {
				document.body.appendChild( WEBGL.getWebGLErrorMessage() );
			}
            var clock = new THREE.Clock();
            var delta;
            var elapsed = 0;
			var container, stats;
			var camera, controls, scene, renderer;
			var mesh, texture;
			var worldWidth = 256, worldDepth = 256,
				worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;
			var helper;
			var raycaster = new THREE.Raycaster();
			var mouse = new THREE.Vector2();
            var sphere;
            var moveForward = false;
            var moveBackward = false;
            var moveRight = false;
            var moveLeft = false;
            var velocity = new THREE.Vector3(0,0,0);
            var acceleration = 200;
            var friction = .5
            // var movementSpeed = 200;
            var pipeColors = [
                '#02999C',
                '#FDD659',
                '#EF5E19',
                '#969696',
                '#E93B2D',
                '#FFD03D',
                '#CF1F09',
            ];
	        var pipes = [];		
            init();
			animate();
			function init() {
                /**
                 * get container and append threejs renderer
                 */
				container = document.getElementById( 'container' );
				container.innerHTML = "";
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
				container.appendChild( renderer.domElement );
				
                scene = new THREE.Scene();
				// scene.background = new THREE.Color( 0xbfd1e5 );
                scene.background = new THREE.Color( 0x000000 );

                /**
                 * create orbit controls and camera
                 */
                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 10, 20000 );
				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.minDistance = 10;
				controls.maxDistance = 10000;
				controls.maxPolarAngle = Math.PI / 2;
				camera.position.y = controls.target.y + 2000;
				camera.position.x = 2000;
				controls.update();
                

                /**
                 * create ground plane
                 */
                // var geometry = new THREE.PlaneBufferGeometry( 3000, 3000, worldWidth - 1, worldDepth - 1 );
				// geometry.rotateX( - Math.PI / 2 );
				// mesh = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0xbfd1e5 } ) );
                var geometry = new THREE.PlaneGeometry(1000, 1000, worldWidth - 1, worldDepth - 1);
                var material = new THREE.MeshLambertMaterial({color: 0xffff00, side: THREE.DoubleSide});
				geometry.rotateX( - Math.PI / 2 );
                mesh = new THREE.Mesh(geometry, material);
                // mesh.castShadow = true;
                mesh.receiveShadow = true;
				scene.add(mesh);

				
                /**
                 * directional light
                 */
                var directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
                directionalLight.position.set(500, 500, 500);
                directionalLight.castShadow = true;
                directionalLight.shadowCameraVisible = true;
                scene.add( directionalLight );
                var lightHelper = new THREE.DirectionalLightHelper(directionalLight, 5);
                scene.add(lightHelper);
                directionalLight.target = mesh;
                directionalLight.shadow.mapSize.width = 5000;
                directionalLight.shadow.mapSize.height = 5000;
                directionalLight.shadow.camera.left = -1000;
                directionalLight.shadow.camera.right = 1000;
                directionalLight.shadow.camera.top = -1000;
                directionalLight.shadow.camera.bottom = 1000;
                directionalLight.shadow.camera.near = 1;
                directionalLight.shadow.camera.far = 2000;
                console.log(directionalLight);
                scene.add(new THREE.CameraHelper(directionalLight.shadow.camera));

                /**
                 * raycaster helper geometry
                 */
                var geometry = new THREE.ConeBufferGeometry( 20, 100, 3 );
				geometry.translate( 0, 50, 0 );
				geometry.rotateX( Math.PI / 2 );
				helper = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial() );
				scene.add( helper );


                /**
                 * add sphere to scene
                 */
                var spheregeometry = new THREE.SphereGeometry( 30, 32, 32 );
                var spherematerial = new THREE.MeshLambertMaterial( {color: 0xffff00} );
                sphere = new THREE.Mesh( spheregeometry, spherematerial );
                sphere.castShadow = true;
                scene.add( sphere );
                sphere.position.set(0, 700, 500);

                /**
                 * init pipes
                 */
                addPipe();
                pipes.forEach(function(pipe) {
                    console.log(pipe);
                    pipe.createSegment();
                });
                
                
                // Stats
				stats = new Stats();
				container.appendChild( stats.dom );

				// Events
                container.addEventListener( 'mousemove', onMouseMove, false );
				window.addEventListener( 'resize', onWindowResize, false );

                // key controls
                window.addEventListener('keydown', function(event) {
                    if(event.key ===  'w' || event.code === 'KeyW'){
                      console.log('forward');
                      moveForward = true;
                    }
                    if(event.key === 's' || event.code === 'KeyS'){
                      console.log('backward');
                      moveBackward = true;
                    }
                    if(event.key === 'd' || event.code === 'KeyD'){
                      console.log('right');
                      moveRight = true;
                    }
                    if(event.key === 'a' || event.code === 'KeyA'){
                      console.log('left');
                      moveLeft = true;
                    }
                });
        

                // key controls
        window.addEventListener('keyup', function(event) {
          if(event.key ===  'w' || event.code === 'KeyW'){
            moveForward = false;
          }
          if(event.key === 's' || event.code === 'KeyS'){
            moveBackward = false;
          }
          if(event.key === 'd' || event.code === 'KeyD'){
            moveRight = false;
          }
          if(event.key === 'a' || event.code === 'KeyA'){
            moveLeft = false;
          }
        });

			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}




			function animate() {
				requestAnimationFrame( animate );
				render();

                delta = clock.getDelta();
               
                // var interval = .5; // seconds 
                // elapsed += delta;
                // if(elapsed > interval) {
                //     elapsed -= interval;
                //     console.log('interval hit');
                // }
                // var roundedElapsedTime = Math.floor(clock.getElapsedTime());

                // animate pipes 
                pipes.forEach(function(pipe) {
                    pipe.draw();
                });






                // ball movement controlled by player
                velocity.x *= friction;
                velocity.z *= friction;
                if(moveForward){
                  // sphere.position.x -= movementSpeed*delta;
                  velocity.x -= acceleration * delta;
                }
                if(moveBackward){
                  // sphere.position.x += movementSpeed*delta;
                  velocity.x += acceleration * delta;
                }
                if(moveRight){
                  // sphere.position.z -= movementSpeed*delta;
                  velocity.z -= acceleration * delta;
                }
                if(moveLeft){
                  velocity.z += acceleration * delta;
                }
                sphere.position.x += velocity.x;
                sphere.position.z += velocity.z;

				stats.update();
			}
			function render() {
				renderer.render( scene, camera );
			}
			function onMouseMove( event ) {
				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
				raycaster.setFromCamera( mouse, camera );
				// See if the ray from the camera into the world hits one of our meshes
				var intersects = raycaster.intersectObject( mesh );
				// Toggle rotation bool for meshes that we clicked
				if ( intersects.length > 0 ) {
					helper.position.set( 0, 0, 0 );
					helper.lookAt( intersects[ 0 ].face.normal );
					helper.position.copy( intersects[ 0 ].point );
				}
			}

            function addPipe() {
                pipes.push(new Pipe());
            }

            function Pipe() {
                this.start = false;
                this.position = new THREE.Vector3();
                this.color = undefined;
                this.interval = .5; // seconds 
                this.constraints = {
                    maxX: 500,
                    minX: -500,
                    maxY: 500,
                    minY: -500,
                    maxZ: 500,
                    mini: -500,
                };
                this.randColor = function() {
                    var index = Math.floor(Math.random()*pipeColors.length);
                    return pipeColors[index];
                }
                this.randPosition = function() {
                    var x = Math.floor((Math.random() * this.constraints.maxX*2) + this.constraints.minX);
                    var y = Math.floor((Math.random() * this.constraints.maxY*2) + this.constraints.minY);
                    var z = Math.floor((Math.random() * this.constraints.maxZ*2) + this.constraints.minZ);
                    return new THREE.Vector3(x,y,z);
                }
                this.createJoint = function() {
                    var geometry = new THREE.SphereBufferGeometry( 5, 32, 32 );
                    var material = new THREE.MeshLambertMaterial( {color: this.color} );
                    var sphere = new THREE.Mesh( geometry, material );
                    // sphere.position.set(10, 40, 30);
                    sphere.position.add(this.position);
                    sphere.castShadow = true;
                    scene.add( sphere );
                }
                this.createSegment = function() {
                    // var direction = new THREE.Vector3(0, magnitude, 0);
                    // var position = this.position.clone();
                    // var v1 = position;
                    // var v2 = this.position.add(direction);
                    // var path1  = new THREE.LineCurve3(v1, v2);
                    // var path2  = new THREE.LineCurve3(new THREE.Vector3(100, 60, 10), new THREE.Vector3(100, 140, 60));
                    // var path3  = new THREE.LineCurve3(new THREE.Vector3(300, 20, 20), new THREE.Vector3(-70, -200, 0));
                    // pipe.curves = [path1, path2, path3];


                    // rotate around x axis
                    // x, ycosθ - zsinθ, ysinθ + zcosθ

                    // rotate around y axis
                    // xcosθ + zsinθ, y, -xsinθ + zcosθ 
                    
                    // rotate around z axis
                    // xcosθ - ysinθ, xsinθ + ycosθ, z

                    var magnitude = 100;
                    var pipe = new THREE.CurvePath();
                    var geometry = new THREE.TubeGeometry(pipe, 20, 2, 8, false);
                    var material = new THREE.MeshLambertMaterial({color: 0x00ff00});
                    var mesh = new THREE.Mesh(geometry, material);
                    mesh.castShadow = true;
                    console.log(mesh);
                    scene.add(mesh);
                    // scene.add(segment);
                }
                this.draw = function() {
                    if (!this.start) return;
                    elapsed += delta;
                    if(elapsed > this.interval) {
                        elapsed -= this.interval;
                        this.createSegment();
                        // this.createJoint();
                        // console.log('interval hit');
                    }
                }
                this.init = function() {
                    // random color 
                    this.color = this.randColor();
                    
                    // random starting position
                    this.position = this.randPosition();

                    // start drawing
                    this.start = true;
                }
                this.init();
            };

		</script>

	</body>
</html>
